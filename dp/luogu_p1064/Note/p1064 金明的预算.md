金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

主件 附件

电脑 打印机，扫描仪

书柜 图书

书桌 台灯，文具

工作椅 无

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有00个、11个或22个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的NN元。于是，他把每件物品规定了一个重要度，分为55等：用整数1−51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是1010元的整数倍）。他希望在不超过NN元（可以等于NN元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

请你帮助金明设计一个满足要求的购物单。

* 这道题是比较有难度的一道动态规划。我一开始的解题思路是这样的
  * 这道题如果忽略“主件 附件”这一条件，那么就是一个简单的01背包求最大，01背包求最大是非常基础的一类dp题目，一维数组开头设0，从后往前遍历m次就解决。那么怎么解决这个主件和附件的条件呢？好像难度比较大的dp题目都是在基础的dp问题上把一个原本固定的值变成变量，比如我前段时间刚做完的另一道绿题“p1541 乌龟棋”，转化为多重背包后发现每个物品的value是根据前面已选的牌的类型变化的，而像采药这种基础问题中，物品的value是固定不变的，所以乌龟棋的解决方案就是用高维dp动态计算每张牌的价值。对于本题来说，可选物品的数量是变化的，自变量是选了哪些主件。
  * 我想到了一种比较简单，看起来也make sense的做法。就是把所有物品进行排序，把主件放在前面，附件放在所有附件后面，然后再跑01完全背包求最大，等所有主件都跑完了以后trace back，看看选了哪些主件，然后继续01背包跑附件，如果选了主件，那么这个附件的价值就是input的价值，否则就是0。但是经过实验发现这种方法无法保证求出最大值，原因是（这里不考虑压维，方便讲解）:
    * 我们知道在01背包问题中f[i][j]代表的是考虑前i件物品在容量j下可以得到的最大值，这里的“考虑前i件物品”应该是把前i件物品选择方案带来的影响都考虑在内，!包括选择他们带来的附件可选性的影响！但是我的算法没有考虑这一点。所以我的f[i][j]并不是我想表示的意思，就好像最优子问题的嵌套中发生了“泄漏”。

* 我的错误代码

```c
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <algorithm>
#include <set>
#define maxm 65
#define maxn 32010

using namespace std;

//v = value p = importance q = type
int n,m, v[maxm], p[maxm], q[maxm], od[maxm], f[maxm][maxn];
int ch[maxm];

bool cmp(int a, int b){
	return q[a] < q[b];
}


void init(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		v[i] = a; p[i] = b; q[i] = c;
		od[i] = i;
	}
	// Sort the objects to make sure that type main comes first
	sort(od+1, od+1+m, cmp);
}	

int main(){
	init();

	int last = -1; //last main item
	int tp = -1;
	for(int i = 1; i <= m; i++){
		if(q[od[i]]==0){
			tp = od[i];
		}else{
			last = tp;
			break;
		}
	}

	//Start dp
	for(int i = 1; i <= m; i++){
		int k = od[i]; // The index of the object to consider
		int value = (q[k] == 0)?(p[k]*v[k]):(ch[q[k]]*p[k]*v[k]); //Compute value according to cost
		for(int j = 1; j <= n; j++){
			if(j >= v[k]){
				f[i][j] = max(f[i-1][j - v[k]]+value,f[i-1][j]);
				
			}else{
				f[i][j] = f[i-1][j];
			}
		}
		if(k == last){ //reconstruct the path
			int pos = n;
			for(int c = i; c > 0; c--){
				if(f[c][pos] != f[c-1][pos]){
					ch[c] = 1;
					pos = pos - v[od[c]];
				}
			}
		}
	}

	//answer
	cout << f[m][n];
	return 0;
}

```

* 这里插一句背包问题的分类
  * 01完全背包求最大
    * f[0] = 0, 从后往前跑，因为物品只有一件
  * 01完全背包求方案数
    * f[0] = 1, 从后往前跑，因为物品只有一件
  * 无限完全背包求最大 — Ribbon cut
    * f[0] = 0, 对于每件物品从前往后跑
  * 无限完全背包求方案数— Money System
    * f[0] = 1, 对于每件物品从前往后跑

* 这道题的正确思路
  * 其实这个思路曾经在我脑子中闪过，但是我觉得实现起来过于困难所以放弃了。事实证明实现起来确实不简单。
  * 正确思路就是每个主件和它所有附件分为一组，在每个小组内跑一遍01完全背包求最大，但是做一个特殊操作，就是把dp数组内除了0以外的所有值设为-1，跑完01背包之后跑一遍所有数组，只要不是-1的位置都提出来保存起来。这样相当于得到了这个组内在所有能恰好用完的预算下的最大值。等所有组都跑完储存好数据之后，再对所有组跑一遍01完全背包求最大，这时候把每个组看作一个单独的物品，但是这个物品可能有多个状态（多态hhh…）也就是比max的时候要遍历我们之前组内01背包的时候得到的所有可能的状态。
  * 总体来说，这个题有两个维度的dp，这个“维度”不是说dp数组的维度，是说整个dp算法的维度。即每个组内跑一遍01背包，再对整体跑一遍01背包
* 注释详细的代码：

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct cas
{
    int v,p,q; //价格 重要度 类型
}a[60],pat[60][60]; //a: 存储原始数据    pat:[主件编号][附件编号]   t[i]:主件i后有多少附件  cnt[i]:第i个主件的分组中有多少个方案
int n,m,t[60],V[60][10],P[60][10],cnt[60],f[32000],ans;
int main()
{
    //读取，存储
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a[i].v,&a[i].p,&a[i].q);//正常的读入
        if(a[i].q)//如果这个物品是附件
        {
            t[a[i].q]++;
            pat[a[i].q][t[a[i].q]].v=a[i].v;
            pat[a[i].q][t[a[i].q]].p=a[i].p;
            pat[a[i].q][t[a[i].q]].q=a[i].q;//把它存在相应的主件的分组中
        }
    }


    //对每个主件分组进行01背包处理    参考：洛谷p1164 小a点菜（压到一维的01完全背包）
    for(int i=1;i<=m;i++)// 对于每件物品
    {
        if(t[i])//如果当前物品为有附件的主件
        {
            //a[i]：当前正遍历的有附件的主件  pat[i][j]: 当前正在遍历的附件

            memset(f,-1,sizeof(f));//恰好背包的处理，-1表示不恰好取到此价值
            f[0]=0;//恰好背包的处理 base case

            //这里的算法是：压到一维的01完全背包
            for(int j=1;j<=t[i];j++) //对于这个主件所有的附件
                for(int k=n-a[i].v;k>=pat[i][j].v;k--)
                    if(f[k]<f[k-pat[i][j].v]+pat[i][j].v*pat[i][j].p && f[k-pat[i][j].v]!=-1) //恰好背包的判断
                        f[k]=f[k-pat[i][j].v]+pat[i][j].v*pat[i][j].p; //很平常的01状态转移


            for(int j=0;j<=n-a[i].v;j++)
                if(f[j]!=-1)//恰好背包的判断，这种附件组合满足题意
                {
                    cnt[i]++;
                    V[i][cnt[i]]=j+a[i].v; 
                    P[i][cnt[i]]=f[j]+a[i].v*a[i].p;//把此情况存在主件i的分组中，为分组背包做好处理
                }

        }
        //如果当前物品为主件(不一定非要有附件),注意这个if只要是主件都会进，如果有附件会进上面的if，之后这个if的作用只是
        //再把单独买主件的情况加进来，如果上面if没走，这个主件就没有附件，那么他这个组就只有单独买他自己的这种方案
        if(!a[i].q)
        {
            cnt[i]++;
            V[i][cnt[i]]=a[i].v;
            P[i][cnt[i]]=a[i].v*a[i].p;//存储
        }
    }

    //清空f数组，并在分组背包求解中重新利用
    memset(f,0,sizeof(f));

    //分组背包求解
    for(int i=1;i<=m;i++) //对于每件物品
        for(int j=n;j>=0;j--) //对于所有容量（在本题中为预算）
            for(int k=1;k<=cnt[i];k++) //对于每个主件分组的每个方案（附件cnt[i]为0，不会走）
                if(j>=V[i][k]) //如果目前的预算可以买这个方案
                    f[j]=max(f[j],f[j-V[i][k]]+P[i][k]);//分组背包的计算

    //在dp数组中寻找答案
    for(int i=0;i<=n;i++)
        ans=max(ans,f[i]);
    printf("%d",ans);//输出
    return 0;
}
```

