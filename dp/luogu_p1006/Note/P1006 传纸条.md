小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个mm行nn列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1(1,1)，小轩坐在矩阵的右下角，坐标(m,n)(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用00表示），可以用一个0−1000−100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这22条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的22条路径。

* 这道题有很多隐藏条件，解题需要看到这些隐藏条件
  * 首先，一来一回传纸条，相当于从一个地方传两张纸条，然后要求路径不重复，这是首先需要意识到的，所以我们可以把题目转换成以左上角为起点找两条路
  * 第二就是需要看到，路径本质上是右 下 右 下这样一系列选择的排列组合，从一个点到另一个点所需要的右的数量加上左的数量是相同的，所以我们要找的这两条路永远是在数组的对角线上，横纵坐标的和相等
  * 然后采用三维dp，第一维存的是对角线的和，第二维是下面那条路的纵坐标，第三维是上面那条路的纵坐标，状态转移方程首先第一维减1，相当于左边一条对角线，然后 1\. 二三维都减1，说明上一步都是从左边过来。 2\. 二三维都不动，说明上一步都是从上面过来 3。第二维减一第三维不动 4\. 第三维减一第二维不动。从这四种情况中取最大然后加上当前两个格子的值就是这一步的最优byte size decision
  * 别忘记填base case

* AC 代码

```c
#include <algorithm>
#include <iostream>

using namespace std;
#define N 55

int m,n,arr[N][N];
int f[2*N][N][N];
int main(){
	//readin data
	scanf("%d%d",&m,&n);
	for(int i = 1; i <= m; i++){
		for(int j = 1; j <= n; j++){
			scanf("%d",arr[i]+j);
		}
	}

	for(int i = 3; i < m+n; i++){
		for(int j = 1; j < i - 1; j++){
			for(int k = j+1; k <= i - 1; k++){
				int best = f[i][j][k];
				if(f[i-1][j][k] > best) best = f[i-1][j][k]; //both come from above
				if(f[i-1][j-1][k-1] > best) best = f[i-1][j-1][k-1]; //both come from left
				if(f[i-1][j][k-1] > best) best = f[i-1][j][k-1];
				if(f[i-1][j-1][k] > best) best = f[i-1][j-1][k];
				f[i][j][k] = best + arr[i-j][j] + arr[i-k][k];
 			}
		}
	}

	cout << f[m+n-1][n-1][n] << endl;

	return 0;
}
```

