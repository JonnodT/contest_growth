乌龟棋的棋盘是一行NN个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第NN格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中MM张爬行卡片，分成4种不同的类型（MM张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。

游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。

很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。

现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？

* 这道题我一上来的思路是遍历所有位置（格子），然后往前看1/2/3/4个格子，看看哪个可以转移，取可以转移的最大的那个，这种思路在无限背包中应该是可行的，比如类似coin change那样，看看最后是否刚好能到某个值。但是这个题是每张卡片的数量是有限的，所以是一个多重背包问题，遇到多重背包应该往dp“物品”上思考，这道题中的“物品”就是卡片。那么如果把所有卡片放到一个大数组中类似“采药”那样可以吗？答案是不行，因为背包的value值比较特殊，回忆采药中大概就是某一个物品有一个固定的value值，但是这道题中一个卡片（物品）的value值是变化的，是跟前面选了多少张卡片（走到什么位置）有关的（在代码中是变量sc），也就是说前面每张卡片选的数量决定了最后一个卡片的value，所以在每个状态转移的节点，我们需要把每张卡片的数量记下来，总共有四种卡片，所以采用一个四维数组。

* AC 代码

```c
#include<iostream>
#include<string>
#include<iomanip>
#include<stdio.h>
#define maxn 355
#define maxc 44

using namespace std;

int n,m,c[5],r[maxn],dp[maxc][maxc][maxc][maxc];

void init(){
	scanf("%d%d",&n, &m);
	//read road
	for(int i = 1; i <= n; i++){
		scanf("%d", &r[i]);
	}
	//read cards
	for(int i = 1; i <= m; i++){
		int num;
		scanf("%d",&num);
		c[num]++;
	}

	//Initialize score of the starting point
	dp[0][0][0][0] = r[1];
}

int main(){
	init();

	for(int i = 0; i <= c[1]; i++){
		for(int j = 0; j <= c[2]; j++){
			for(int k = 0; k <= c[3]; k++){
				for(int d = 0; d <= c[4]; d++){
					int sc = r[1+i + j*2 + k*3 + d*4]; //计算value值
					if(d!=0) dp[i][j][k][d] = max(dp[i][j][k][d], dp[i][j][k][d-1] + sc);
					if(k!=0) dp[i][j][k][d] = max(dp[i][j][k][d], dp[i][j][k-1][d] + sc);
					if(j!=0) dp[i][j][k][d] = max(dp[i][j][k][d], dp[i][j-1][k][d] + sc);
					if(i!=0) dp[i][j][k][d] = max(dp[i][j][k][d], dp[i-1][j][k][d] + sc);
				}
			}
		}
	}
	cout << dp[c[1]][c[2]][c[3]][c[4]]<< endl;
}	

```