* 母牛们不但创建了它们自己的政府而且选择了建立了自己的货币系统。由于它们特殊的思考方式，它们对货币的数值感到好奇。

  传统地，一个货币系统是由1,5,10,20 或 25,50, 和 100的单位面值组成的。

  母牛想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。

  举例来说, 使用一个货币系统 {1,2,5,10,...}产生 18单位面值的一些可能的方法是:18x1, 9x2, 8x2+2x1, 3x5+2+1,等等其它。 写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数将会适合long long (C/C++) 和 Int64 (Free Pascal)，即在0 到2^63-1之间。

* 这道题一看也是背包问题，所以这里对背包问题做个总结
* 背包问题大致可以分为01背包和完全背包
  * 01背包就是每个物品有一件，然后规定一个最大重量，在这个最大重量内求能拿的物品的最大价值。比如采药
  * 完全背包就是说每个物品有无限件，然后求把一个背包刚好塞满，没有任何剩余
    * 能放的最多的物品数
      * 比如codeforces189 cut ribbon
    * 能放物品的总方案数
      * 比如这道题
* 完全背包
  * 两类完全背包问题都可以利用压维来解决，也就是都可以使用一维数组，遍历所有物品种类，然后往里放。如果是求最大/最小就取max，如果是求方案数就把方案数加起来
  * 以这道题为例，假设目前遍历到了a面值硬币，从一个值往前a位，前面的那个值是一个已经考虑过a的方案数，而当前位置是a之前的所有面值硬币（我们在遍历硬币种类）的方案数。也就是说当前总额的方案数 = 放这个面值硬币 + 不放这个面值的硬币。如果放了以后也可以继续放，如果不放就是只考虑前面所有硬币的方案数。

```c
#include <iostream>
#include <algorithm>
#define maxn 30

using namespace std;

int v,n, arr[maxn];
long long dp[10005];

int main(){
	scanf("%d%d",&v,&n);
	for(int i = 1; i <= v; i++){
		scanf("%d",arr+i);
	}

	dp[0] = 1;
	for(int i = 1; i <= v; i++){
		for(int j = arr[i]; j <= n; j++){
			dp[j] += dp[j - arr[i]];
		}
	}


	cout << dp[n] <<endl;
	return 0;
}
```