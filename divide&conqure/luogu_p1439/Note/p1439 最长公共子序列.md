给出1-n的两个排列P1和P2，求它们的最长公共子序列。

* 这道题用dp最长公共子序列复杂度过不了，O(n^2)。但是由于序列有一个特殊的性质，即元素是1-n的排列，可以利用“离散化”这个技巧把这道题变成最长升序列，然后就可以用p1020中的贪心/二分策略在O(nlogn)复杂度内求出答案

* 离散化
  * 就是利用数据的相对特性把数据重新进行映射，从而达到简化题目的目的
  * 观察这道题，如果第一个数组是1 2 3 4 5 … n， 第二个数组是乱序，最长公共子序列岂不就是第二个数组的最长升序列吗？但是第一个数组不一定是1 2 3 4 5 … n 。 因此我们用离散化的技巧把他变成1 2 3 4 5 … n
  * 在这道题中，我们可以把第一个数组的每一个元素对应上1 2 3 4 5 … 举个例子
    * 比如第一个数组为 5 3 4 1 2
      * 那么我们建一个map，在这道题中可以用一个简单的数组实现
      * 然后我们把5当作第一个元素，3当作第二个元素，4当作第三个元素，1当作第四个元素，2当作第五个元素，这就形成了一种映射。第一个数组就变成了1 2 3 4 5
      * 然后读取第二个数组，如果第二个数组是 2 4 3 5 1, 那么根据上面的映射2是第5个元素，4是第三个元素，3是第二个元素，5是第一个元素，1是第四个元素。那么第二个数组就变成了5 3 2 1 4，这时候求5 3 2 1 4这个数组的最长升序列，求出来的就是最长公共子序列了

* AC 代码

```c
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <unordered_map>
#define maxn 100005

using namespace std;

int n, d[maxn], dp[maxn];



int main(){

	//读取数据并离散化处理
	unordered_map<int, int> map;
	scanf("%d", &n);
	if(n==0){
		cout << 0;
		return 0;
	}
	for(int i = 0; i < n; i++){
		int a;
		scanf("%d", &a);
		//这里用unordered map做的，其实也可以用一个简单的数组做
		//这就相当于上面说的，a是第i+1个元素，形成了一种离散化映射
		map.insert(make_pair(a, i+1));
	}
	for(int i = 0; i < n; i++){
		int a;
		scanf("%d", &a);
		d[i] = map[a];
	}


	//nlogn最长上升子序列
	dp[0] = d[0];
	int len = 0;
	for(int i = 1; i < n; i++){
		if(d[i] > dp[len]){
			dp[++len] = d[i];
		}else{
			int index = lower_bound(dp, dp + len + 1, d[i]) - dp;
			dp[index] = d[i];
		}
	}	
	cout << len + 1; 


	return 0;
}
```

* 最后还要说一下这种贪心求上升子序列的方法，这里要注意，dp数组（仅仅是个名字，跟dp没关系）存的数据并不是真正的上升子序列！！！他只是一个媒介，让我们可以数出来最长上升子序列的长度。
  * 比如数据是 6 8 10 2 3 12 15
  * dp数组读到 6 8 10 的时候由于是升序列，所以就是存的6 8 10
    * 然后读到2，把6踢了
    * 2 8 10 注意，这并不是一个符合规定的最长升序列，2在10之后，但是len不变
      * 这时候再往后读，读到12的时候10被替换，len依然是3，然后读到15，len变成4
      * 由此可见，dp存的并不是真正的上升序列，而是一个帮我们count的工具

